# encoding: utf-8
"""Implementations for various useful completers.

These are all loaded by default by IPython.
"""
#-----------------------------------------------------------------------------
#  Copyright (C) 2010-2011 The IPython Development Team.
#
#  Distributed under the terms of the BSD License.
#
#  The full license is in the file COPYING.txt, distributed with this software.
#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# Imports
#-----------------------------------------------------------------------------

# Stdlib imports
import glob
import inspect
import os
import re
import sys
from importlib import import_module
from importlib.machinery import all_suffixes


# Third-party imports
from time import time
from zipimport import zipimporter

# Our own imports
from .completer import expand_user, compress_user
from .error import TryNext
from ..utils._process_common import arg_split

# FIXME: this should be pulled in with the right call via the component system
from IPython import get_ipython

from typing import List

#-----------------------------------------------------------------------------
# Globals and constants
#-----------------------------------------------------------------------------
_suffixes = all_suffixes()

# Time in seconds after which the rootmodules will be stored permanently in the
# ipython ip.db database (kept in the user's .ipython dir).
TIMEOUT_STORAGE = 2

# Time in seconds after which we give up
TIMEOUT_GIVEUP = 20

# Regular expression for the python import statement
import_re = re.compile(r'(?P<name>[^\W\d]\w*?)'
                       r'(?P<package>[/\\]__init__)?'
                       r'(?P<suffix>%s)$' %
                       r'|'.join(re.escape(s) for s in _suffixes))

# RE for the ipython %run command (python + ipython scripts)
magic_run_re = re.compile(r'.*(\.ipy|\.ipynb|\.py[w]?)$')

#-----------------------------------------------------------------------------
# Local utilities
#-----------------------------------------------------------------------------

def module_list(path):
    """Return the list containing the names of the modules available in the
    given folder.

    Args:
        path:
    """
    # sys.path has the cwd as an empty string, but isdir/listdir need it as '.'
    if path == '':
        path = '.'

    # A few local constants to be used in loops below
    pjoin = os.path.join

    if os.path.isdir(path):
        # Build a list of all files in the directory and all files
        # in its subdirectories. For performance reasons, do not
        # recurse more than one level into subdirectories.
        files = []
        for root, dirs, nondirs in os.walk(path, followlinks=True):
            subdir = root[len(path)+1:]
            if subdir:
                files.extend(pjoin(subdir, f) for f in nondirs)
                dirs[:] = [] # Do not recurse into additional subdirectories.
            else:
                files.extend(nondirs)

    else:
        try:
            files = list(zipimporter(path)._files.keys())
        except:
            files = []

    # Build a list of modules which match the import_re regex.
    modules = []
    for f in files:
        m = import_re.match(f)
        if m:
            modules.append(m.group('name'))
    return list(set(modules))


def get_root_modules():
    """Returns a list containing the names of all the modules available in the
    folders of the pythonpath.

    ip.db['rootmodules_cache'] maps sys.path entries to list of modules.
    """
    ip = get_ipython()
    if ip is None:
        # No global shell instance to store cached list of modules.
        # Don't try to scan for modules every time.
        return list(sys.builtin_module_names)

    rootmodules_cache = ip.db.get('rootmodules_cache', {})
    rootmodules = list(sys.builtin_module_names)
    start_time = time()
    store = False
    for path in sys.path:
        try:
            modules = rootmodules_cache[path]
        except KeyError:
            modules = module_list(path)
            try:
                modules.remove('__init__')
            except ValueError:
                pass
            if path not in ('', '.'): # cwd modules should not be cached
                rootmodules_cache[path] = modules
            if time() - start_time > TIMEOUT_STORAGE and not store:
                store = True
                print("\nCaching the list of root modules, please wait!")
                print("(This will only be done once - type '%rehashx' to "
                      "reset cache!)\n")
                sys.stdout.flush()
            if time() - start_time > TIMEOUT_GIVEUP:
                print("This is taking too long, we give up.\n")
                return []
        rootmodules.extend(modules)
    if store:
        ip.db['rootmodules_cache'] = rootmodules_cache
    rootmodules = list(set(rootmodules))
    return rootmodules


def is_importable(module, attr, only_modules):
    """
    Args:
        module:
        attr:
        only_modules:
    """
    if only_modules:
        return inspect.ismodule(getattr(module, attr))
    else:
        return not(attr[:2] == '__' and attr[-2:] == '__')


def try_import(mod: str, only_modules=False) -> List[str]:
    """Try to import given module and return list of potential completions.

    Args:
        mod (str):
        only_modules:
    """
    mod = mod.rstrip('.')
    try:
        m = import_module(mod)
    except:
        return []

    m_is_init = '__init__' in (getattr(m, '__file__', '') or '')

    completions = []
    if (not hasattr(m, '__file__')) or (not only_modules) or m_is_init:
        completions.extend( [attr for attr in dir(m) if
    """Exception raise by an experimental feature in this module.

    Wrap code in :any:`provisionalcompleter` context manager if you are
    certain you want to use an unstable feature.
    """
    completions_set.discard('__init__')
    return list(completions_set)


#-----------------------------------------------------------------------------
# Completion-related functions.
    """This context manager has to be used in any place where unstable completer
    behavior and API may be called.

    >>> with provisionalcompleter():
    ...     completer.do_experimental_things() # works

    >>> completer.do_experimental_things() # raises.

    Args:
        action:

    Note:
        Unstable

        By using this context manager you agree that the API in use may change
        without warning, and that you won't complain if they do so.

        You also understand that, if the API is not to your liking, you should
        report a bug to explain your use case upstream.

        We'll be happy to get your feedback, feature requests, and improvements
        on any of the unstable APIs!
    """
    def do_complete(self, event):
        return completions

    get_ipython().set_hook('complete_command',do_complete, str_key = cmd)

def module_completion(line):
    """Returns a list containing the completion possibilities for an import
    line.

    The line looks like this : 'import xml.d' 'from xml.dom import'

    Args:
        line:
    """
    in the string is odd.

    Args:
        s:

    Returns:
        * *If there is an open quote, the quote character is returned.  Else, return*
        * *False.*
    """

    # 'from xy<tab>' or 'import xy<tab>'
    if nwords < 3 and (words[0] in {'%aimport', 'import', 'from'}) :
        if nwords == 1:
            return get_root_modules()
        mod = words[1].split('.')
        if len(mod) < 2:
            return get_root_modules()
        completion_list = try_import('.'.join(mod[:-1]), True)
        return ['.'.join(mod[:-1] + [el]) for el in completion_list]

    """Escape a string to protect certain characters.

    Args:
        s:
        protectables:
    """
    if nwords >= 3 and words[0] == 'from':
        mod = words[1]
        return try_import(mod)

#-----------------------------------------------------------------------------
# Completers
#-----------------------------------------------------------------------------
# These all have the func(self, event) signature to be used as custom
# completers

    """Expand ``~`` -style usernames in strings.

    This is similar to :func:`os.path.expanduser`, but it computes and
    returns extra information that will be useful if the input was being used in
    computing completions, and you wish to return the completions with the
    original '~' instead of its expanded value.

    Args:
        path (str): String to be expanded. If no ~ is present, the output is the
            same as the input.

    Returns:
        * **newpath** (*str*) -- Result of ~ expansion in the input path.
        * **tilde_expand** (*bool*) -- Whether any expansion was performed or
          not.
        * **tilde_val** (*str*) -- The value that ~ was replaced with.
    """
    Args:
        self:
        event:
    """
    comps = arg_split(event.line, strict=False)
    # relpath should be the current token that we need to complete.
    if (len(comps) > 1) and (not event.line.endswith(' ')):
        relpath = comps[-1].strip("'\"")
    else:
        relpath = ''

    #print("\nev=", event)  # dbg
    #print("rp=", relpath)  # dbg
    #print('comps=', comps)  # dbg

    lglob = glob.glob
    isdir = os.path.isdir
    relpath, tilde_expand, tilde_val = expand_user(relpath)

    # Find if the user has already typed the first filename, after which we
    # should complete on all files, since after the first one other files may
    # be arguments to the input script.

    if any(magic_run_re.match(c) for c in comps):
        matches =  [f.replace('\\','/') + ('/' if isdir(f) else '')
                            for f in lglob(relpath+'*')]
    else:
    """Does the opposite of expand_user, with its outputs.

    Args:
        path (str):
        tilde_expand (bool):
        tilde_val (str):
    """
                for f in lglob(relpath+'*.py') + lglob(relpath+'*.ipy') +
                lglob(relpath+'*.ipynb') + lglob(relpath + '*.pyw')]

        matches = dirs + pys

    #print('run comp:', dirs+pys) # dbg
    return [compress_user(p, tilde_expand, tilde_val) for p in matches]
    """key for sorting completions

    This does several things:

    - Demote any completions starting with underscores to the end
    - Insert any %magic and %%cellmagic completions in the alphabetical order by
      their name

    Args:
        word:
    """
    """
    ip = get_ipython()
    relpath = event.symbol

    #print(event) # dbg
    if event.line.endswith('-b') or ' -b ' in event.line:
        # return only bookmark completions
        bkms = self.db.get('bookmarks', None)
        if bkms:
            return bkms.keys()
        else:
            return []

    if event.symbol == '-':
        width_dh = str(len(str(len(ip.user_ns['_dh']) + 1)))
        # jump in directory history by number
        fmt = '-%0' + width_dh +'d [%s]'
        ents = [ fmt % (i,s) for i,s in enumerate(ip.user_ns['_dh'])]
        if len(ents) > 1:
            return ents
        return []

    if event.symbol.startswith('--'):
        return ["--" + os.path.basename(d) for d in ip.user_ns['_dh']]

    # Expand ~ in path and normalize directory separators.
    relpath, tilde_expand, tilde_val = expand_user(relpath)
    relpath = relpath.replace('\\','/')

    """This is a workaround to communicate to the UI that Jedi has crashed and
    to report a bug. Will be used only id :any:`IPCompleter.debug` is set to
    true.

    Added in IPython 6.0 so should likely be removed for 7.0
    """

        found.append(d)

        """
        Args:
            name:
        """
    if not found:
        if os.path.isdir(relpath):
            return [compress_user(relpath, tilde_expand, tilde_val)]

        # if no completions so far, try bookmarks
        bks = self.db.get('bookmarks',{})
        bkmatches = [s for s in bks if s.startswith(event.symbol)]
        if bkmatches:
            return bkmatches

        raise TryNext

    """Completion object used and return by IPython completers.

    This act as a middle ground :any:`Completion` object between the
    :any:`jedi.api.classes.Completion` object and the Prompt Toolkit completion
    object. While Jedi need a lot of information about evaluator and how the
    code should be ran/inspected, PromptToolkit (and other frontend) mostly need
    user facing information.

    - Which range should be replaced replaced by what.
    - Some metadata (like completion type), or meta information to displayed to
      the use user.

    For debugging purpose we can also store the origin of the completion
    (``jedi``, ``IPython.python_matches``, ``IPython.magics_matches``...).

    Warning:
        Unstable

        This function is unstable, API may change without warning. It will also
        raise unless use in proper context manager.
    """

    Note that snowman is not a valid python3 combining character but will be
    expanded. Though it will not recombine back to the snowman character by the
    completion machinery.

    This will not either back-complete standard sequences like \n, \b ...

    Used on Python 3 only.

        """
        Args:
            start (int):
            end (int):
            text (str):
            type (str):
            _origin:
            signature:
        """
    Args:
        text:
    """
    """Checks if obj is an instance of module.class_name if loaded

    Args:
        obj:
        module:
        class_name:
    """
    """Convert the position of the cursor in text (0 indexed) to a line
    number(0-indexed) and a column number (0-indexed) pair

    Position should be a valid position in ``text``.

    Args:
        text (str): The text in which to calculate the cursor offset
        """Equality and hash do not hash the type (as some completer may not be
        able to infer the type), but are use to (partially) de-duplicate
        completion.

        Completely de-duplicating completion is a bit tricker that just
        comparing as it depends on surrounding text, which Completions are not
        aware of.

        Args:
            other:
        """
    """
    """Convert the (line,column) position of the cursor in text to an offset in
    a string.

    Args:
        text (str): The text in which to calculate the cursor offset
        line (int): Line of the cursor; 0-indexed
        column (int): Column of the cursor 0-indexed

    Returns:
        Position of the cursor in text, 0-indexed.:

    """Deduplicate a set of completions.

    Completions coming from multiple sources, may be different but end up
    having the same effect when applied to ``text``. If this is the case, this
    will consider completions as equal and only emit the first encountered.

    Not folded in `completions()` yet for debugging purpose, and to detect
    when the IPython completer does return things that Jedi does not, but should
    be at some point.

    Args:
        text (str): text that should be completed.
        completions (_IC): iterator over the completions to deduplicate

    Yields:
        `Completions` objects

    Warning:
        Unstable

        This function is unstable, API may change without warning.
    """
        Assuming the text is of the form NAME.NAME....[NAME], and is
        evaluatable in self.namespace or self.global_namespace, it will be
        evaluated and its attributes (as revealed by dir()) are used as possible
        completions. (For class instances, class members are also considered.)

        WARNING: this can still invoke arbitrary C code, if an object with a
        __getattr__ hook is evaluated.

        Args:
            text:
        """
        """Compute matches when text is a simple name.

        Return a list of all keywords, built-in functions and names currently
        defined in self.namespace or self.global_namespace that match.

    """Rectify a set of completions to all have the same ``start`` and ``end``

    :any:`jedi.api.classes.Completion` s returned by Jedi may not have the
    same start and end, though the Jupyter Protocol requires them to behave like
    so. This will readjust the completion to have the same ``start`` and ``end``
    by padding both extremities with surrounding text.

    During stabilisation should support a ``_debug`` option to log which
    completion are return by the IPython completer and not found in Jedi in
    order to make upstream bug report.

    Args:
        text (str): text that should be completed.
        completions (_IC): iterator over the completions to rectify
        _debug:

    Warning:
        Unstable

        This function is unstable, API may change without warning. It will also
        raise unless use in proper context manager.
    """
            **kwargs:
        """
        """Split a line of text with a cursor at the given position.

        Args:
            line:
            cursor_pos:
        """
        """Set the delimiters for line splitting.

        Args:
            delims:
        """
        """Return the string of delimiter characters."""
        """
        Args:
            delims:
        """
    """An object to split an input line in a manner similar to readline.

    By having our own implementation, we can expose readline-like completion
    in a uniform manner to all frontends. This object only needs to be given the
    line of text to be split and the cursor position on said line, and it
    returns the 'word' to be completed on at the cursor after splitting the
    entire line.

    What characters are used as splitting delimiters can be controlled by
    setting the ``delims`` attribute (this is a property that internally
    automatically builds the necessary regular expression)
    """