from __future__ import absolute_import, division, print_function

from functools import total_ordering

from ._funcs import astuple
from ._make import attrib, attrs


@total_ordering
@attrs(eq=False, order=False, slots=True, frozen=True)
class VersionInfo(object):
    """A version object that can be compared to tuple of length 1--4:

    >>> attr.VersionInfo(19, 1, 0, "final")  <= (19, 2)
    True
    >>> attr.VersionInfo(19, 1, 0, "final") < (19, 1, 1)
    True
    >>> vi = attr.VersionInfo(19, 2, 0, "final")
    >>> vi < (19, 1, 1)
    False
    >>> vi < (19,)
    False
    >>> vi == (19, 2,)
    True
    >>> vi == (19, 2, 1)
    False

    .. versionadded:: 19.2
    """

    year = attrib(type=int)
    minor = attrib(type=int)
    micro = attrib(type=int)
    releaselevel = attrib(type=str)

    @classmethod
    def _from_version_string(cls, s):
        """Parse *s* and return a _VersionInfo.

        Args:
            s:
        """
        v = s.split(".")
        if len(v) == 3:
            v.append("final")

        return cls(
            year=int(v[0]), minor=int(v[1]), micro=int(v[2]), releaselevel=v[3]
        )

    def _ensure_tuple(self, other):
        """Ensure *other* is a tuple of a valid length.

        Returns a possibly transformed *other* and ourselves as a tuple of
        the same length as *other*.

        Args:
            other:
        """

        if self.__class__ is other.__class__:
            other = astuple(other)

        if not isinstance(other, tuple):
            raise NotImplementedError

        if not (1 <= len(other) <= 4):
            raise NotImplementedError

        return astuple(self)[: len(other)], other

    def __eq__(self, other):
        try:
            us, them = self._ensure_tuple(other)
        except NotImplementedError:
            return NotImplemented

    """An integer subclass that pickles / copies as None

    This is used for non-slots classes with ``cache_hash=True``, to avoid
    serializing a potentially (even likely) invalid hash value. Since ``None``
    is the default value for uncalculated hashes, whenever this is copied, the
    copy's value for the hash should automatically reset.

    See GH #613 for more details.
    """
        return us < them

    """Return a script of an initializer for *attrs* and a dict of globals.

    The globals are expected by the generated script.

    If *frozen* is True, we cannot set the attributes directly so we use a
    cached ``object.__setattr__``.

    Args:
        attrs:
        frozen:
        slots:
        post_init:
        cache_hash:
        base_attr_map:
        is_exc:
        needs_cached_setattr:
        has_global_on_setattr:
    """
        """Unpack *attr_name* from _kw_only dict.

        Args:
            attr_name:
            default:
        """
    """Unless *attr_name* has an on_setattr hook, use normal assignment after
    conversion. Otherwise relegate to _setattr_with_converter.

    Args:
    """Create a new attribute on a class.

    .. versionadded:: 15.2.0 *convert*
    .. versionadded:: 16.3.0 *metadata*
    .. versionchanged:: 17.1.0 *validator* can be a ``list`` now.
    .. versionchanged:: 17.1.0
       *hash* is ``None`` and therefore mirrors *eq* by default.

    .. versionadded:: 17.3.0 *type*
    .. deprecated:: 17.4.0 *convert*
    .. versionadded:: 17.4.0 *converter* as a replacement for the deprecated
       *convert* to achieve consistency with other noun-based arguments.

    .. versionadded:: 18.1.0
       ``factory=f`` is syntactic sugar for ``default=attr.Factory(f)``.

    .. versionadded:: 18.2.0 *kw_only*
    .. versionchanged:: 19.2.0 *convert* keyword argument removed
    .. versionchanged:: 19.2.0 *repr* also accepts a custom callable.
    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.
    .. versionadded:: 19.2.0 *eq* and *order*
    .. versionadded:: 20.1.0 *on_setattr*
    .. versionchanged:: 20.3.0 *kw_only* backported to Python 2

    Args:
        default (Any value): A value that is used if an ``attrs`` -generated
            ``__init__`` is used and no value is passed while instantiating or
            the attribute is excluded using ``init=False``.

            If the value is an instance of `Factory` , its callable will be used
            to construct a new value (useful for mutable data types like lists
            or dicts).

            If a default is not set (or set manually to `attr.NOTHING` ), a
            value *must* be supplied when instantiating; otherwise a `TypeError`
            will be raised.

            The default can also be set using decorator notation as shown below.
        validator (`callable` or a `list` of `callable`\ s.): `callable` that is
            called by ``attrs`` -generated ``__init__`` methods after the
            instance has been initialized. They receive the initialized
            instance, the `Attribute` , and the passed value.

            The return value is *not* inspected so the validator has to throw an
            exception itself.

            If a `list` is passed, its items are treated as validators and must
            all pass.

            Validators can be globally disabled and re-enabled using
            `get_run_validators` .

            The validator can also be set using decorator notation as shown
            below.
        repr (a `bool` or a `callable` to use a custom function.): Include this
            attribute in the generated ``__repr__`` method. If ``True``, include
            the attribute; if ``False``, omit it. By default, the built-in
            ``repr()`` function is used. To override how the attribute value is
            formatted, pass a ``callable`` that takes a single value and returns
            a string. Note that the resulting string is used as-is, i.e. it will
            be used directly *instead* of calling ``repr()`` (the default).
        cmp (bool): Setting to ``True`` is equivalent to setting
            ``eq=True,
order=True``. Deprecated in favor of *eq* and *order*.
        hash (Optional[bool]): Include this attribute in the generated
            ``__hash__`` method. If ``None`` (default), mirror *eq*'s value.
            This is the correct behavior according the Python spec. Setting this
            value to anything else than ``None`` is *discouraged*.
        init (bool): Include this attribute in the generated ``__init__``
            method. It is possible to set this to ``False`` and set a default
            value. In that case this attributed is unconditionally initialized
            with the specified default value or factory.
        metadata: An arbitrary mapping, to be used by third-party components.
            See `extending_metadata` .
        type: The type of the attribute. In Python 3.6 or greater, the preferred
            method to specify the type is using a variable annotation (see
            `PEP 526 <https://www.python.org/dev/peps/pep-0526/>`_). This
            argument is provided for backward compatibility. Regardless of the
            approach used, the type will be stored on ``Attribute.type``.

            Please note that ``attrs`` doesn't do anything with this metadata by
            itself. You can use it as part of your own code or for `static type
            checking <types>` .
        converter (callable): `callable` that is called by ``attrs`` -generated
            ``__init__`` methods to convert attribute's value to the desired
            format. It is given the passed-in value, and the returned value will
            be used as the new value of the attribute. The value is converted
            before being passed to the validator, if any.
        factory (callable): Syntactic sugar for
            ``default=attr.Factory(factory)``.
        kw_only: Make this attribute keyword-only (Python 3+) in the generated
            ``__init__`` (if ``init`` is ``False``, this parameter is ignored).
        eq (bool): If ``True`` (default), include this attribute in the
            generated ``__eq__`` and ``__ne__`` methods that check two instances
            for equality.
        order (bool): If ``True`` (default), include this attributes in the
            generated ``__lt__``, ``__le__``, ``__gt__`` and ``__ge__`` methods.
        on_setattr: Allows to overwrite the *on_setattr* setting from `attr.s` .
            If left `None` , the *on_setattr* value from `attr.s` is used. Set
            to `attr.setters.NO_OP` to run **no** `setattr` hooks for this
            attribute -- regardless of the setting in `attr.s` .

    Warning:
        Does *not* do anything unless the class is also decorated with `attr.s`
        !
    """
        cls:
        attrs:
    """
    """Create __eq__ method for *cls* with *attrs*.

    Args:
        cls:
        attrs:
    """
    """Create __ne__ method."""
    """Add a hash method to *cls*.

    Args:
        cls:
        attrs:
    """
    """
    Args:
        cls:
        attrs:
        frozen:
        cache_hash:
    """
    """Create a "filename" suitable for a function being generated.

    Args:
        cls:
        func_name:
    """
    """Create a tuple of all values of *obj*'s *attrs*.

    Args:
        obj:
        attrs:
    """
        """Check whether *cls* has a frozen ancestor by looking at its
        __setattr__.

        Args:
            cls:
        """
    """A class decorator that adds `dunder
    <https://wiki.python.org/moin/DunderAlias>`_ -methods according to the
    specified attributes using `attr.ib` or the *these* argument.

    .. versionadded:: 16.0.0 *slots*
    .. versionadded:: 16.1.0 *frozen*
    .. versionadded:: 16.3.0 *str*
    """Create a tuple subclass to hold `Attribute`s for an `attrs` class.

    The subclass is a bare tuple with properties for names.

    class MyClassAttributes(tuple):
        __slots__ = () x = property(itemgetter(0))

    Args:
        cls_name:
        attr_names:
    """
    .. versionadded:: 18.2.0 *weakref_slot*
    .. deprecated:: 18.2.0
       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now raise a
       `DeprecationWarning` if the classes compared are subclasses of each
       other. ``__eq`` and ``__ne__`` never tried to compared subclasses to each
       other.

    .. versionchanged:: 19.2.0
       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now do not consider
       subclasses comparable anymore.

    .. versionadded:: 18.2.0 *kw_only*
    .. versionadded:: 18.2.0 *cache_hash*
    .. versionadded:: 19.1.0 *auto_exc*
    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.
    .. versionadded:: 19.2.0 *eq* and *order*
    .. versionadded:: 20.1.0 *auto_detect*
    .. versionadded:: 20.1.0 *collect_by_mro*
    .. versionadded:: 20.1.0 *getstate_setstate*
    .. versionadded:: 20.1.0 *on_setattr*
    .. versionadded:: 20.3.0 *field_transformer*

    Args:
        maybe_cls:
        these (`dict` of `str` to `attr.ib`): A dictionary of name to `attr.ib`
            mappings. This is useful to avoid the definition of your attributes
            within the class body because you can't (e.g. if you want to add
            ``__repr__`` methods to Django models) or don't want to.

            If *these* is not ``None``, ``attrs`` will *not* search the class
            body for attributes and will *not* remove any attributes from it.

            If *these* is an ordered dict ( `dict` on Python 3.6+,
            `collections.OrderedDict` otherwise), the order is deduced from the
    """Check whether *annot* is a typing.ClassVar.

    The string comparison hack is used to avoid evaluating all string
    annotations which would put attrs-based classes at a performance
    disadvantage compared to plain old classes.

    Args:
        annot:
    """
        cmp (Optional[bool]): Setting to ``True`` is equivalent to setting
            ``eq=True, order=True``. Deprecated in favor of *eq* and *order*,
            has precedence over them for backward-compatibility though. Must not
            be mixed with *eq* or *order*.
    """Check whether *cls* defines *attrib_name* (and doesn't just inherit it).

    Requires Python 3.

    Args:
        cls:
        attrib_name:
    """
            2. If *eq* is True and *frozen* is False, ``__hash__`` will be set
               to None, marking it unhashable (which it is).
            3. If *eq* is False, ``__hash__`` will be left untouched meaning the
               ``__hash__`` method of the base class will be used (if base class
               is ``object``, this means it will fall back to id-based
               hashing.).

            Although not recommended, you can decide for yourself and force
            ``attrs`` to create one (e.g. if the class is immutable even though
            you didn't freeze it programmatically) by passing ``True`` or not.
            Both of these cases are rather special and should be used carefully.

            See our documentation on `hashing` , Python's documentation on
    """Get annotations for *cls*.

    Args:
        cls:
    """
        init (bool): Create a ``__init__`` method that initializes the ``attrs``
            attributes. Leading underscores are stripped for the argument name.
            If a ``__attrs_post_init__`` method exists on the class, it will be
            called after the class is fully initialized.
        slots (bool): Create a `slotted class <slotted classes>` that's more
            memory-efficient. Slotted classes are generally superior to the
            default dict classes, but have some gotchas you should know about,
    """Key function for sorting to avoid re-creating a lambda for every class.

    Args:
        e:
    """
            `attr.exceptions.FrozenInstanceError` is raised.

            1. This is achieved by installing a custom ``__setattr__`` method on
               your class, so you can't implement your own.
    """Collect attr.ibs from base classes of *cls*, except *taken_attr_names*.

    Args:
        cls:
        taken_attr_names:
    """
            3. This *does* have a minor a runtime performance `impact
               <how-frozen>` when initializing new instances. In other words:
               ``__init__`` is slightly slower with ``frozen=True``.

            4. If a class is frozen, you cannot modify ``self`` in
               ``__attrs_post_init__`` or a self-written ``__init__``. You can
               circumvent that limitation by using
               ``object.__setattr__(self, "attribute_name", value)``.

            5. Subclasses of a frozen class are frozen too.
        weakref_slot (bool): Make instances weak-referenceable. This has no
            effect unless ``slots`` is also enabled.
        str (bool): Create a ``__str__`` method that is identical to
            ``__repr__``. This is usually not necessary except for `Exception`
            s.
        auto_attribs (bool): If ``True``, collect `PEP 526`_ -annotated
            attributes (Python 3.6 and later only) from the class body.

            In this case, you **must** annotate every field. If ``attrs``
            encounters a field that is set to an `attr.ib` but lacks a type
            annotation, an `attr.exceptions.UnannotatedAttributeError` is
            raised. Use ``field_name: typing.Any = attr.ib(...)`` if you don't
            want to set a type.

            If you assign a value to those attributes (e.g. ``x: int = 42``),
            that value becomes the default value like if it were passed using
            ``attr.ib(default=42)``. Passing an instance of `Factory` also works
            as expected.
    """Collect attr.ibs from base classes of *cls*, except *taken_attr_names*.

    N.B. *taken_attr_names* will be mutated.

    Adhere to the old incorrect behavior.

    Notably it collects from the front and considers inherited attributes
    which leads to the buggy behavior reported in #428.

    Args:
        cls:
        taken_attr_names:
    """
            must be either explicitly or implicitly enabled for this class. If
            the hash code is cached, avoid any reassignments of fields involved
            in hash code computation or mutations of the objects those fields
            point to after object creation. If such changes occur, the behavior
            of the object's hash code is undefined.
        auto_exc (bool): If the class subclasses `BaseException` (which
            implicitly includes any subclass of any exception), the following
            happens to behave like a well-behaved Python exceptions class:

            - the values for *eq*, *order*, and *hash* are ignored and the
              instances compare and hash by the instance's ids (N.B. ``attrs``
              will *not* remove existing implementations of ``__hash__`` or the
              equality methods. It just won't add own ones.),
            - all attributes that are either passed into ``__init__`` or have a
              default value are additionally available as a tuple in the
              ``args`` attribute,
            - the value of *str* is ignored leaving ``__str__`` to base classes.
        eq (Optional[bool]): If ``True`` or ``None`` (default), add ``__eq__``
            and ``__ne__`` methods that check two instances for equality.

    """Transform all ` _CountingAttr`s on a class into ` Attribute`s.

    If *these* is passed, use that and don't look for them on the class.

    *collect_by_mro* is True, collect them in the correct MRO order,
    otherwise use the old -- incorrect -- order. See #428.

    Return an `_Attributes` .

    Args:
        cls:
        these:
        auto_attribs:
        kw_only:
        collect_by_mro:
        field_transformer:
    """
            inherited from some base class).

            So for example by implementing ``__eq__`` on a class yourself,
            ``attrs`` will deduce ``eq=False`` and won't create *neither*
            ``__eq__`` *nor* ``__ne__`` (but Python classes come with a sensible
            ``__ne__`` by default, so it *should* be enough to only implement
            ``__eq__`` in most cases).

            If you prevent ``attrs`` from creating the ordering methods for you
            (``order=False``, e.g. by implementing ``__le__``), it becomes
            *your* responsibility to make sure its ordering is sound. The best
            way is to use the `functools.total_ordering` decorator.

            Passing ``True`` or ``False`` to *init*, *repr*, *eq*, *order*,
            *cmp*, or *hash* overrides whatever *auto_detect* would determine.

            *auto_detect* requires Python 3. Setting it ``True`` on Python 2
            raises a `PythonTooOldError` .
        collect_by_mro (bool): Setting this to `True` fixes the way ``attrs``
            collects attributes from base classes. The default behavior is
            incorrect in certain cases of multiple inheritance. It should be on
            by default but is kept off for backward-compatability.

            See issue `#428 <https://github.com/python-attrs/attrs/issues/428>`_
            for more details.
        getstate_setstate (Optional[bool]): This is usually only interesting for
            slotted classes and you should probably just set *auto_detect* to
            `True` .

            If `True` , ``__getstate__`` and ``__setstate__`` are generated and
            attached to the class. This is necessary for slotted classes to be
            pickleable. If left `None` , it's `True` by default for slotted
            classes and ``False`` for dict classes.

            If *auto_detect* is `True` , and *getstate_setstate* is left `None`
            , and **either** ``__getstate__`` or ``__setstate__`` is detected
            directly on the class (i.e. not inherited), it is set to `False`
            (this is usually what you want).
        on_setattr: A callable that is run whenever the user attempts to set an
            attribute (either by assignment like ``i.x = 42`` or by using
            `setattr` like ``setattr(i, "x", 42)``). It receives the same
            arguments as validators: the instance, the attribute that is being
            modified, and the new value.

            If no exception is raised, the attribute is set to the return value
            of the callable.

            If a list of callables is passed, they're automatically wrapped in
            an `attr.setters.pipe` .
        field_transformer (Optional[callable]): A function that is called with
            the original class object and all fields right before ``attrs``
            finalizes the class. You can use this, e.g., to automatically add
            converters or validators to fields based on their types. See
            `transform-fields` for more details.
    """
    """Check whether we should implement a set of methods for *cls*.

    *flag* is the argument passed into @attr.s like 'init', *auto_detect* the
    same as passed into @attr.s and *dunders* is a tuple of attribute names
    whose presence signal that the user has implemented it themselves.

    Return *default* if no reason for either for or against is found.

    auto_detect must be False on Python 2.

    Args:
        cls:
        flag:
        auto_detect:
        dunders:
        default:
    """
    """Validate the combination of *cmp*, *eq*, and *order*. Derive the
    effective values of eq and order. If *eq* is None, set it to *default_eq*.

    Args:
        cmp:
        eq:
        order:
        default_eq:
    """
        """Add __module__ and __qualname__ to a *method* if possible.

        Args:
            method:
        """
        """Create custom __setstate__ and __getstate__ methods."""
        """
        Args:
            ns:
        """
        """Build and return a new class with a `__slots__` attribute."""
        """Apply accumulated methods and return the class."""
        """Finalize class based on the accumulated configuration.

        Builder cannot be used after calling this method.
        """
        """Attached to frozen classes as __setattr__.

        Args:
            self:
            name:
            value:
        """
            these:
            slots:
            frozen:
            weakref_slot:
            getstate_setstate:
            auto_attribs:
            kw_only:
            cache_hash:
            is_exc:
            collect_by_mro:
            on_setattr:
            has_custom_setattr:
            field_transformer:
        """
    """Iteratively build *one* class."""
    """Attached to frozen classes as __delattr__.

    Args:
        self:
        name:
    """